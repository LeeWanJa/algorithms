데이터는 아까 말한 것 처럼 Vertex 구조체와 그 구조체들의 배열을 저장한 Graph class의 vertices로 구성돼있어.
vertices에 저장된 Vertex 구조체들은 각각 이웃된 Vertex 정점을 vector로 차례차례 저장하고 있지.
처음 그래프를 생성하면 매개변수에 정수숫자를 집어넣어야 하는데, 그 숫자는 vertices의 크기를 뜻하고, 0 부터 n - 1 의 값을 가진 Vertex를 차례로 생성해서 vertices에 넣어.
예를들어 Graph g(3)은 value가 0, 1, 2 인 Vertex를 크기가 3으로 생성된 vector vertices 안에 차례로 집어넣는거지.
이후 AddDiEdge 혹은 AddBiEdge 함수를 이용해서 단방향 혹은 양방향 간선을 생성해.
그렇게 관계가 설정된 후, 정확히 말하면 vertices의 각 요소 안에 out_neighbors의 요소들이 결정되면..
DFS(n) 함수를 호출해서 시작 노드 n부터 깊이 우선 탐색을 진행해. 
level을 이용해서 깊이를 표현하고, current_time을 이용해서 탐색의 횟수를 표현해.

	{
		Graph g(6);

		g.AddDiEdge(0, 2);
		g.AddDiEdge(2, 1);
		g.AddDiEdge(2, 3);
		g.AddDiEdge(3, 4);
		g.AddDiEdge(1, 5);
		g.AddDiEdge(2, 4);
		g.AddBiEdge(3, 5); // 주의: 양방향 간선

		g.DFS(2);
	}

이 예제를 통해 DFS(2)의 탐색 흐름을 간단하게 설명해볼게.
DFS(2, 0) = 2번 정점 방문 -> DFS(1, 1) = 2번 정점의 첫 번째 이웃 1번 정점 방문 -> DFS(5, 2) = 1번 정점의 첫 번째 이웃 5번 정점 방문 -> DFS(3, 3) = 5번 정점의 첫 번째 이웃 3번 정점 방문 -> DFS(4, 4) = 3번 정점 첫 번째 이웃 4번 정점 방문, 하지만 4번 정점은 out_neighbor 에 저장된 정점이 없기 때문에 4 done을 출력하고 다시 DFS(3, 3) 으로 돌아옴 -> DFS(5, 3) = 3번 정점은 5번 정점을 호출하지만 이미 5번 정점은 방문했기 때문에 if문에서 걸러지고 더 이상 방문할 노드가 없어진 3번 정점은 3 done을 출력하고 3번 정점을 호출한 5번 정점으로 다시 돌아옴 -> 5번 정점도 3번 정점 이외의 이웃 노드가 없었기 때문에 자신을 호출한 1번 정점으로 돌아옴 -> 이하 동문.. 1번 정점도 자신을 호출한 2번 정점으로 다시 돌아옴 -> 2번 정점은 아직 이웃한 3, 4 번 정점을 호출할 수 있지만, 해당 정점은 모두 방문됐기 때문에 2 done을 출력하고 프로그램 종료